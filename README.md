# پروژه ویرایشگر ساده اشکال (Simple Shape Editor)

این پروژه به عنوان تمرین کلاسی درس **برنامه‌نویسی وب** در دانشگاه **صنعتی‌شریف** پیاده‌سازی شده است. هدف از این پروژه، ساخت یک برنامه‌ی ساده‌ی تحت وب با استفاده از کتابخانه **React** است که به کاربر اجازه می‌دهد اشکال هندسی (دایره، مربع و مثلث) را به یک بوم (Canvas) اضافه کند.


---

## 🚀 قابلیت‌های پیاده‌سازی شده

- **ساختار ماژولار کامپوننت‌ها**: برنامه به کامپوننت‌های منطقی و قابل استفاده مجدد مانند `Header`، `ToolsSidebar`، `Canvas` و `Footer` تقسیم شده است.
- **مدیریت وضعیت مرکزی (Centralized State Management)**: تمام وضعیت‌های اصلی برنامه، از جمله لیست اشکال (`shapes`) و ابزار انتخاب شده (`selectedTool`)، در کامپوننت اصلی (`App.jsx`) مدیریت می‌شوند. این الگو باعث سادگی در انتقال داده و جلوگیری از ناهماهنگی وضعیت می‌شود.
- **افزودن اشکال با دو روش**:
    1.  **کشیدن و رها کردن (Drag and Drop)**: کاربر می‌تواند ابزار مورد نظر را از نوار ابزار کناری بکشد و در هر نقطه از بوم رها کند تا شکل در همان مختصات ایجاد شود.
    2.  **انتخاب و کلیک (Select and Click)**: کاربر می‌تواند ابتدا یک ابزار را انتخاب کرده و سپس در هر نقطه‌ای از بوم کلیک کند تا شکل در آنجا اضافه شود.
- **نمایش تعداد کل اشکال**: یک شمارنده در فوتر برنامه، تعداد کل اشکال موجود در بوم را به صورت زنده نمایش می‌دهد.
- **استایل‌دهی مدرن با CSS Modules**: برای جلوگیری از تداخل استایل‌ها و کپسوله‌سازی استایل‌های هر کامپوننت، از `CSS Modules` استفاده شده است.

---

## 🛠️ تکنولوژی‌ها و ابزارهای مورد استفاده

- **React.js**: برای ساخت رابط کاربری پویا و مبتنی بر کامپوننت.
- **Vite**: به عنوان ابزار ساخت (Build Tool) و سرور توسعه (Dev Server) برای راه‌اندازی سریع و بهینه پروژه.
- **CSS Modules**: برای استایل‌دهی ماژولار و ایزوله.
- **JavaScript (ES6+)**: زبان اصلی برنامه‌نویسی.
- **HTML5**: برای ساختاردهی صفحات وب.

---

## 🔧 نحوه راه‌اندازی و اجرای پروژه

برای اجرای پروژه به صورت محلی، مراحل زیر را دنبال کنید:

1.  ابتدا مخزن را از گیت‌هاب کلون کنید:
```
git clone https://github.com/your-username/your-repository-name.git
```
2.  وارد پوشه پروژه شوید:
```
cd repository-root-directory
```
3.  بسته‌های مورد نیاز را با استفاده از `npm` یا `yarn` نصب کنید:
```
npm install
# or
# yarn install
```
4.  پروژه را در حالت توسعه اجرا کنید:
```
npm run dev
# or
# yarn dev
```
5.  برنامه در آدرس `http://localhost:5173` (یا پورت دیگری که در ترمینال اعلام می‌شود) قابل مشاهده خواهد بود.
عکس نمونه از ui برنامه‌ی paint ما:
---<img width="1852" height="912" alt="image" src="https://github.com/user-attachments/assets/571551c7-357a-4a35-b588-53f232cb6f4d" />


##  معماری و ساختار پروژه

ساختار پروژه بر اساس الگوی **Single Source of Truth** طراحی شده است. کامپوننت `App.jsx` به عنوان مرکز کنترل عمل می‌کند و وظایف زیر را بر عهده دارد:

-   **`App.jsx` (کامپوننت والد)**:
    -   نگهداری `state` مربوط به لیست اشکال (`shapes`) و ابزار انتخاب شده (`selectedTool`).
    -   تعریف توابع منطقی اصلی مانند `handleSelectTool` برای انتخاب ابزار و `handleAddShape` برای افزودن شکل جدید.
    -   ارسال `state`ها و توابع به کامپوننت‌های فرزند از طریق `props`.

-   **`ToolsSidebar.jsx` (کامپوننت فرزند)**:
    -   مسئول نمایش ابزارها (دایره، مربع، مثلث).
    -   دریافت `selectedTool` و `onSelectTool` از `App` برای نمایش حالت انتخاب شده و اطلاع‌رسانی به والد هنگام انتخاب یک ابزار جدید.
    -   پیاده‌سازی منطق `onDragStart` برای ثبت نوع ابزار در حال کشیده شدن.

-   **`Canvas.jsx` (کامپوننت فرزند)**:
    -   مسئول نمایش بوم و رندر کردن اشکال.
    -   دریافت لیست `shapes` برای نمایش آن‌ها.
    -   دریافت تابع `onAddShape` برای افزودن شکل جدید.
    -   پیاده‌سازی منطق `onDragOver` و `onDrop` برای پذیرش ابزارهای کشیده شده و فراخوانی `onAddShape` با مختصات دقیق.

-   **`Header.jsx` و `Footer.jsx` (کامپوننت‌های نمایشی)**:
    -   کامپوننت‌های ساده‌ای که صرفاً برای نمایش اطلاعات (عنوان و شمارنده) به کار می‌روند و داده‌های خود را از `App` دریافت می‌کنند.

این معماری که به آن **"Lifting State Up"** نیز گفته می‌شود، باعث می‌شود که جریان داده یک‌طرفه (از والد به فرزند) و قابل پیش‌بینی باشد و مدیریت برنامه در مقیاس بزرگ‌تر ساده‌تر شود.

---

## 💡 گزارش استفاده از هوش مصنوعی (AI)

در این پروژه، برای سرعت بخشیدن به فرآیند توسعه و رفع برخی باگ‌های پیچیده، از یک دستیار هوش مصنوعی (Gemini 2.5 Pro) کمک گرفته شد. موارد استفاده به شرح زیر است:

1.  **رفع باگ اولیه مربوط به `state`**: در ابتدای کار، یک شکل پیش‌فرض در بوم وجود داشت. AI به درستی تشخیص داد که این مشکل به دلیل مقداردهی اولیه نادرست `useState` برای `shapes` در کامپوننت `App.jsx` است و پیشنهاد داد که مقدار اولیه به یک آرایه خالی `[]` تغییر کند.

2.  **پیاده‌سازی کامل منطق Drag and Drop**: چالش اصلی پروژه، پیاده‌سازی صحیح عملکرد کشیدن و رها کردن بود. پس از تلاش‌های اولیه، باگی رخ داد که در آن، با کشیدن شکل به روی بوم، شمارنده افزایش می‌یافت اما خود شکل نمایش داده نمی‌شد.
    -   AI در ابتدا راه حلی برای `Canvas.jsx` ارائه داد که ناقص بود.
    -   پس از ارائه گزارش دقیق‌تر از مشکل، AI متوجه شد که مشکل اصلی در عدم ارسال داده از مبدأ (`ToolsSidebar`) است. راه حل نهایی و صحیح AI شامل اصلاح هر دو کامپوننت `ToolsSidebar.jsx` (برای ارسال داده با `onDragStart` و `dataTransfer.setData`) و `Canvas.jsx` (برای دریافت داده با `onDrop` و `dataTransfer.getData`) بود.

### مزایا و معایب راه حل تولید شده توسط هوش مصنوعی:

#### ✅ مزایا:
-   **سرعت بالا در شناسایی و حل باگ**: AI توانست به سرعت الگوهای اشتباه در کد را شناسایی کرده و راه حل‌های دقیقی ارائه دهد. این امر به شکل چشمگیری زمان دیباگ را کاهش داد.
-   **ارائه کد استاندارد و بهینه**: کدهای تولید شده توسط AI (مانند استفاده از `useRef` برای دسترسی به DOM و محاسبه مختصات دقیق با `getBoundingClientRect`) کاملاً استاندارد و بهینه بودند.
-   **آموزش مفاهیم جدید**: فرآیند تعامل با AI و تحلیل راه‌حل‌های آن، به درک عمیق‌تر مفاهیمی مانند `Drag and Drop API` در HTML و جریان داده در React کمک کرد.

#### ❌ معایب:
-   **نیاز به ارائه زمینه (Context) دقیق**: هوش مصنوعی بدون داشتن تصویر کامل از ساختار پروژه و ارتباط بین کامپوننت‌ها، ممکن است در ابتدا راه‌حل‌های ناقص یا نادرستی ارائه دهد (همانطور که در اولین تلاش برای حل مشکل Drag and Drop رخ داد). کاربر باید بتواند با ارائه گزارش دقیق، AI را به سمت راه‌حل صحیح هدایت کند.
-   **کاهش فرصت برای آزمون و خطا**: استفاده از AI می‌تواند وسوسه‌انگیز باشد و مانع از تلاش فردی برای حل مسئله شود. این امر ممکن است فرصت یادگیری از طریق آزمون و خطا و دیباگ کردن مستقل را از دانشجو بگیرد.

در نهایت، استفاده از هوش مصنوعی به عنوان یک **ابزار کمکی و یک "همکار برنامه‌نویس" (Pair Programmer)** بسیار مفید بود، اما تکیه کامل بر آن بدون درک عمیق مفاهیم پایه می‌تواند به ضرر فرآیند یادگیری باشد.

